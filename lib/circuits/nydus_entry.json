{"noir_version":"1.0.0-beta.12+9a5b3695b42e391fa27c48e87b9bbb07523d664d","hash":"16621536740077840870","abi":{"parameters":[{"name":"user_key","type":{"kind":"field"},"visibility":"private"},{"name":"token_address","type":{"kind":"field"},"visibility":"public"},{"name":"amount","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"},{"kind":"array","length":4,"type":{"kind":"field"}}]},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/9VYbXPcNBDW3SVtk6PkmuT6CvQVKNCCZL2aBgjQAi1QoEALfLNk62fy0xjWc9aw1flyTizfDDvznPbW9nr32bUseUQW8hfgIVmWUTMeNyOnSohKZxXjrKBZbo2kQlplmGHSyDIznFdGGJ3bXNOcCV4xL3Pu6UJ2kC/aU4aMc/fscWaxoY5tH7AVxfpPo++s0HcbPVw3BbwBuAh4s7GHY2Oyvna0n7ARGaZ2pF+cLDZgLvaacRYImTRjfeDvyDZDQQSZ9AtuKVhM4imblEZNyvZIuoafkWGKO4746xtnypwvnZDzaX3jPrrU9NZW839EliX1hLWXOJcg+0MGvN/SIH2D3yfpHtaDhPkOxeEBWT/Tn/Y+ByTtZJD6TTRr8l7XO+uEO1bRQjnqF5Ky3ocJOcSTS+33C/K6pO6recJaDRnn5bPHKWJD2yoNr8bmSJ8h/TJ5fZV2BXAVcA1wnfz3Eoh9X0E+riL9GtKvR75vAN4CvA145wTfOL5Vq8s47puAW4DbgDvIHiT1Qmic0NdNkq6n7pK0z21cm7uoBreQfhvpd6La3AO8C3gP8P4Jdb+BfNwj3XYV9wEfAD4EfESW6576mX2AfGVWcmYrwa0rrbdQSeFKY0TmPDNgV9ZZmjtvnXNWKO289JlmOS0MrYRp5fc+yvVBRw7qne/HgE/qmm+AA4Z8UWdKxnwlKq5t4ZQrtNcc3kplaZw3lbSysoIX1BZCSmUy+HG6yqvSGeuNbePgIcqVdeQgq/MCCIDcAAcK94FiipmskKBQrQVVtiiphFs4XjippVLC85yLwhvPpdRZoTjlOeyJaJYJ3cZBhnJVHTnQAAPIAZ9ugINHuA9yq5gVJTdwOZNS5JZroUpW5pk03FGdw5NRWe8rpkvJlLaeG1mVSlADN2njQKNcH3Xk4AjwGeBzslhnrJprjpCPaUffx4AvAV8BvibD8/uYpPuqcNavOI8jDp4AvgF8C/huAxw8PRMHWqlcSa3ht1JaemXhX97GwVOU65OOffAM8D3gB8CPZHWPPevAb+z7OeAnwM+AXzr6nnf0/QLwK+A3wO9k+Nq9JMnWItk6Dl525OAV4A/An2Tx1TjmoO+eLBI2ScjnMUm7rx0q562EOU8HyjneD/SNM+V+YDthXM//J/wl/DrPziWM68WG+KP9hJ1PmPNRQl+vBuIv9Te5CwnjrGOL11m1jJGt1s+hXqjP325sdS0vtFwXbDvNuIv8TdLFnwX/02H80/NkWXaRPo2Ohfy3Wq4brfg/jsaTzo3t2Hax5VjwedCMON6Qx040zpHfhFyy4P9wGP+ttZoj/TDKE/N9nCiG4C/MmdtkWcbRsXBu/MyM0sfH4lgmLfcKEnrmENkCn/8CT/cPCs4gAAA=","debug_symbols":"tZrbbmI7DIbfZV1zETtx4syrbG1VtKUjJEQrBkYaVX33SWAdoFKsiJ+5qYFF3Nj+7IQ4n8Pr5vn082m7f3v/Nfz473N4Pmx3u+3Pp937y/q4fd+XTz+/VsP09ul42GzKR8PV8zLqY33Y7I/Dj/1pt1sNv9e70/lLvz7W+7M8rg/lqVsNm/1rkUXh23a3qa++Vsto1x4qGsfBkXUeLrfjqT3eC4/jA8V5fEw347k9nlnzqIC945YG39ZA3k0ayF/Z8E1DaGvIQUYFWZrjLR9knX0g9/gg0RQETt61NCTDByn5yQcpN72ohgbHUyDJRblnDnmJQ+bmHAwWY5rikEJosmgEgnVxpPp4l4oki4romioMIJXjlJDq3ZUh+VaFQWTJhMkV3klqqhArLZLOaZFdU0U0DMlTQLOnpoIEFgdSqzrMrmROzcwwo+E5zdFI2jKDHRwNNrAicZMKEpamCqNK5DSnF3EzHOzRWh3gYs0CV2uOYLm2FHTWOtMMirMKUrnLmVFntmP2zZXPwc70hPsiwMuX9/D65dFF3JxD3/plkummUpM53hONPiP6FKR2MD24l7Hi0AuUxaTWf3BRoblZbwNb+anz6sftahnQahnwahnwMhPw7Az47jIoCHbA96cB36BaZLLTaRZMobmMC06moGQKTqbg67ig1VJwtEVhtCWDaFsKOtE2zXgA2p4XJq488Y3L6GG0YwDRjgKjHSOMdkwg2qYZfWjHDKOdHIi2paATbdOMB6AtaXZm9LnFZQow2klAtFOE0U4JRjspiLZpRh/a6vDjLnSnrfgPJ9OMB6Cd5v06a2iirQKjrRFEWxOMtiqMtmYQbdOMPrQzwWhnBtG2FHSibZrRibZ16kZ5+hXo2cUWlxk9wMzoAWbGDzANNywJriLN42jn0FNYRzDXhRsYbHIebdRYGjrRti2BGx06V9xM7aabg0/WncLHj+QyXHOJHBzTBB5Z2b7o5JvwI0wi/OzMngdMJ7k5JCX6vt1Fg/m0Wz9dWwKiDB+f2fPoZIPxRZ0YXdVNDb10Mf1TujjSXDOu4vqdLruBs3TT3FWrOH5rTbJBqMx7gxhSW4OijHPGGX9AD4jgtoPti64abPqiM8/M3kNnnnnBs8ScR1+W2IzTvHMs9YlahJpk+IUMTe2rDBnPtODQTAvoBRtbQ1euWu2gXj7DA/i0WkJ9uRoeQHh4AOE+/1PCA89HF0Hbl3XE4YQLoYRbXaE+Pq2mUO9aIgHfL8kD8sTqDPXmiSQ0TywNvXliWtKZJyaheJ7IcsQnmm/y5P/ybv2yPdxcTB1ccdtqoPNfPv/1db1aDeEi5CLiRaSL0IvIF0FulDRKHuWoiUI9syxSRhlHmeqBT5E6vs81Kco03CipTrzIoq9uJdmPsuhLZRzLKGO98VVkGqVWKIrMF+nr/Gru+zrBepXO8/TiPMX6nTC9qAb7EmhfTa5dZl+Nrm09r+cXX9X9h+36ebcZr/a+nfYvVzd9j38+pifTXeCPw/vL5vV02FTnn5+VcPwF","file_map":{"50":{"source":"use dep::std;\r\n\r\nuse std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, fixed_base_scalar_mul, multi_scalar_mul};\r\nuse dep::poseidon::poseidon2::Poseidon2;\r\nuse dep::poseidon_ctr_encryption::{poseidon_ctr_encrypt};\r\nuse dep::ec::tecurve::affine::{Curve, Point};\r\nuse dep::ec::consts::te::{baby_jubjub};\r\nuse dep::indexed_merkle_tree::{\r\n    Leaf,\r\n    insert_item,\r\n    empty_root\r\n};\r\n\r\n\r\nmod test;\r\n\r\nfn main(\r\n    user_key: Field,\r\n    token_address: pub Field,\r\n    amount: pub Field,\r\n) -> pub (Field, Field, [Field; 4]) {\r\n  \r\n    let nonce_commitment = \r\n        Poseidon2::hash([user_key, 0 as Field], 2);\r\n    \r\n    let personal_imt_root = \r\n        create_initial_personal_indexed_tree(user_key, token_address, amount);\r\n\r\n    let main_indexed_tree_commitment = \r\n        Poseidon2::hash([personal_imt_root, nonce_commitment], 2);\r\n    \r\n    let user_key_hash = Poseidon2::hash([user_key], 1);\r\n    // === POSEIDON CTR MODE ENCRYPTION ===\r\n\r\n    let view_string = 0x76696577696e675f6b6579 as Field;\r\n    let view_key = Poseidon2::hash([view_string, user_key_hash], 2);\r\n    \r\n    // Encrypt amount, token_address, and personal IMT root\r\n    // We encrypt 3 fields: amount, token_address, personal_imt_root \r\n    let encrypted_amount = poseidon_ctr_encrypt(amount, view_key, 0);\r\n    let encrypted_token_address = poseidon_ctr_encrypt(token_address, view_key, 1);\r\n    let encrypted_personal_imt_root = poseidon_ctr_encrypt(personal_imt_root, view_key, 2);\r\n    \r\n    let encrypted_event = [encrypted_amount, encrypted_token_address, encrypted_personal_imt_root, 0];\r\n    \r\n    (        \r\n        main_indexed_tree_commitment,                      \r\n        nonce_commitment,\r\n        encrypted_event                  \r\n    )\r\n}\r\n\r\n\r\n\r\nfn bjj_pub_key(priv_key: Field) -> Point {\r\n    // Create Baby Jubjub curve using std library\r\n    let bjj = baby_jubjub();\r\n    \r\n    // Get the base point (generator) from the curve\r\n    let base_pt = bjj.base8;\r\n\r\n    // Generate public key: public_key = private_key * base_point\r\n    bjj.curve.mul(priv_key, base_pt)\r\n}\r\n\r\nfn create_initial_personal_indexed_tree(\r\n    user_key: Field,\r\n    token_address: Field,\r\n    amount: Field\r\n) -> Field {\r\n    // === INDEXED MERKLE TREE FOR PERSONAL BALANCES ===\r\n    // Create a new indexed merkle tree to track user's token balances\r\n    // Key: token_address, Value: amount\r\n    \r\n    // Initialize with empty tree (zero item for exclusion proofs)\r\n    let mut leaves: [Leaf; 32] = [Leaf { key: 0, next_idx: 0, next_key: 0, value: 0 }; 32];\r\n    let mut num_leaves = 1; // Start with the zero item\r\n    \r\n    // Insert the initial balance entry\r\n    // Key = token_address, Value = amount\r\n    let (insertion_result, new_leaves, new_num_leaves) = insert_item(\r\n        leaves,\r\n        num_leaves,\r\n        token_address as u64,\r\n        amount\r\n    );\r\n    \r\n    // Return the new root after insertion\r\n    insertion_result.root_after\r\n}\r\n\r\n\r\n\r\n\r\n\r\n","path":"/home/drone/projects/ethrome25/circuits/main/nydus-entry/src/main.nr"},"59":{"source":"use dep::poseidon::poseidon2::Poseidon2;\r\n\r\nglobal MAX_DEPTH: u32 = 32;\r\n\r\npub struct Leaf {\r\n    pub key: u64,\r\n    pub next_idx: u32,\r\n    pub next_key: u64,\r\n    pub value: Field\r\n}\r\n\r\npub struct Proof {\r\n    pub leaf_idx: u32,\r\n    pub leaf: Leaf,\r\n    pub root: Field,\r\n    pub siblings: [Field; MAX_DEPTH]\r\n}\r\n\r\npub struct InsertionResult {\r\n    pub og_leaf_idx: u32,\r\n    pub og_leaf_key: u64,\r\n    pub og_leaf_next_idx: u32,\r\n    pub og_leaf_next_key: u64,\r\n    pub og_leaf_value: Field,\r\n    pub new_leaf_idx: u32,\r\n    pub new_leaf_key: u64,\r\n    pub new_leaf_value: Field,\r\n    pub root_before: Field,\r\n    pub root_after: Field,\r\n    pub siblings_before: [Field; MAX_DEPTH],\r\n    pub siblings_after_og: [Field; MAX_DEPTH],\r\n    pub siblings_after_new: [Field; MAX_DEPTH]\r\n}\r\n\r\npub fn empty_root() -> Field {\r\n    let zero_leaf = Leaf { key: 0, next_idx: 0, next_key: 0, value: 0 };\r\n    Poseidon2::hash([0, 0, 0, 0], 4)\r\n}\r\n\r\nfn hash_leaf(leaf: Leaf) -> Field {\r\n    Poseidon2::hash([\r\n        leaf.key as Field,\r\n        leaf.next_idx as Field,\r\n        leaf.next_key as Field,\r\n        leaf.value\r\n    ], 4)\r\n}\r\n\r\nfn hash_children(left: Field, right: Field) -> Field {\r\n    Poseidon2::hash([left, right], 2)\r\n}\r\n\r\npub fn compute_root(leaves: [Leaf; MAX_DEPTH], num_leaves: u32) -> Field {\r\n    let mut hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    let empty = empty_root();\r\n    \r\n    // Hash all leaves\r\n    for i in 0..MAX_DEPTH {\r\n        if i < num_leaves {\r\n            hashes[i] = hash_leaf(leaves[i]);\r\n        } else {\r\n            hashes[i] = empty;\r\n        }\r\n    }\r\n    \r\n    // Build tree bottom-up with fixed loop bounds\r\n    let mut current_hashes = hashes;\r\n    \r\n    // Level 0: 32 -> 16\r\n    let mut next_hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    for i in 0..16 {\r\n        next_hashes[i] = hash_children(current_hashes[i * 2], current_hashes[i * 2 + 1]);\r\n    }\r\n    current_hashes = next_hashes;\r\n    \r\n    // Level 1: 16 -> 8\r\n    let mut next_hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    for i in 0..8 {\r\n        next_hashes[i] = hash_children(current_hashes[i * 2], current_hashes[i * 2 + 1]);\r\n    }\r\n    current_hashes = next_hashes;\r\n    \r\n    // Level 2: 8 -> 4\r\n    let mut next_hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    for i in 0..4 {\r\n        next_hashes[i] = hash_children(current_hashes[i * 2], current_hashes[i * 2 + 1]);\r\n    }\r\n    current_hashes = next_hashes;\r\n    \r\n    // Level 3: 4 -> 2\r\n    let mut next_hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    for i in 0..2 {\r\n        next_hashes[i] = hash_children(current_hashes[i * 2], current_hashes[i * 2 + 1]);\r\n    }\r\n    current_hashes = next_hashes;\r\n    \r\n    // Level 4: 2 -> 1\r\n    let mut next_hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    next_hashes[0] = hash_children(current_hashes[0], current_hashes[1]);\r\n    \r\n    next_hashes[0]\r\n}\r\n\r\npub fn generate_proof(leaves: [Leaf; MAX_DEPTH], num_leaves: u32, leaf_idx: u32) -> Proof {\r\n    let leaf = leaves[leaf_idx];\r\n    let root = compute_root(leaves, num_leaves);\r\n    let mut siblings: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    let mut hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    let empty = empty_root();\r\n    \r\n    for i in 0..MAX_DEPTH {\r\n        if i < num_leaves {\r\n            hashes[i] = hash_leaf(leaves[i]);\r\n        } else {\r\n            hashes[i] = empty;\r\n        }\r\n    }\r\n    \r\n    let mut idx = leaf_idx;\r\n    \r\n    // Level 0: 32 -> 16\r\n    let sibling_idx = if idx % 2 == 0 { idx + 1 } else { idx - 1 };\r\n    siblings[0] = hashes[sibling_idx];\r\n    let mut new_hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    for i in 0..16 {\r\n        new_hashes[i] = hash_children(hashes[i * 2], hashes[i * 2 + 1]);\r\n    }\r\n    hashes = new_hashes;\r\n    idx = idx / 2;\r\n    \r\n    // Level 1: 16 -> 8\r\n    let sibling_idx = if idx % 2 == 0 { idx + 1 } else { idx - 1 };\r\n    siblings[1] = hashes[sibling_idx];\r\n    let mut new_hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    for i in 0..8 {\r\n        new_hashes[i] = hash_children(hashes[i * 2], hashes[i * 2 + 1]);\r\n    }\r\n    hashes = new_hashes;\r\n    idx = idx / 2;\r\n    \r\n    // Level 2: 8 -> 4\r\n    let sibling_idx = if idx % 2 == 0 { idx + 1 } else { idx - 1 };\r\n    siblings[2] = hashes[sibling_idx];\r\n    let mut new_hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    for i in 0..4 {\r\n        new_hashes[i] = hash_children(hashes[i * 2], hashes[i * 2 + 1]);\r\n    }\r\n    hashes = new_hashes;\r\n    idx = idx / 2;\r\n    \r\n    // Level 3: 4 -> 2\r\n    let sibling_idx = if idx % 2 == 0 { idx + 1 } else { idx - 1 };\r\n    siblings[3] = hashes[sibling_idx];\r\n    let mut new_hashes: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\r\n    for i in 0..2 {\r\n        new_hashes[i] = hash_children(hashes[i * 2], hashes[i * 2 + 1]);\r\n    }\r\n    hashes = new_hashes;\r\n    idx = idx / 2;\r\n    \r\n    // Level 4: 2 -> 1\r\n    let sibling_idx = if idx % 2 == 0 { idx + 1 } else { idx - 1 };\r\n    siblings[4] = hashes[sibling_idx];\r\n    \r\n    Proof { leaf_idx: leaf_idx, leaf: leaf, root: root, siblings: siblings }\r\n}\r\n\r\npub fn verify_proof(proof: Proof) -> bool {\r\n    let mut current_hash = hash_leaf(proof.leaf);\r\n    let mut idx = proof.leaf_idx;\r\n    \r\n    for i in 0..5 {\r\n        if idx % 2 == 0 {\r\n            current_hash = hash_children(current_hash, proof.siblings[i]);\r\n        } else {\r\n            current_hash = hash_children(proof.siblings[i], current_hash);\r\n        }\r\n        idx = idx / 2;\r\n    }\r\n    \r\n    current_hash == proof.root\r\n}\r\n\r\npub fn verify_exclusion_proof(excluded_key: u64, proof: Proof) -> bool {\r\n    let is_after_leaf = excluded_key > proof.leaf.key;\r\n    let is_before_next = (proof.leaf.next_idx == 0) | (excluded_key < proof.leaf.next_key);\r\n    is_after_leaf & is_before_next\r\n}\r\n\r\npub fn verify_insertion_proof(insertion_result: InsertionResult) -> bool {\r\n    let og_leaf = Leaf {\r\n        key: insertion_result.og_leaf_key,\r\n        next_idx: insertion_result.og_leaf_next_idx,\r\n        next_key: insertion_result.og_leaf_next_key,\r\n        value: insertion_result.og_leaf_value\r\n    };\r\n    \r\n    let og_proof = Proof {\r\n        leaf_idx: insertion_result.og_leaf_idx,\r\n        leaf: og_leaf,\r\n        root: insertion_result.root_before,\r\n        siblings: insertion_result.siblings_before\r\n    };\r\n    \r\n    let new_leaf = Leaf {\r\n        key: insertion_result.new_leaf_key,\r\n        next_idx: 0,\r\n        next_key: 0,\r\n        value: insertion_result.new_leaf_value\r\n    };\r\n    \r\n    let new_proof = Proof {\r\n        leaf_idx: insertion_result.new_leaf_idx,\r\n        leaf: new_leaf,\r\n        root: insertion_result.root_after,\r\n        siblings: insertion_result.siblings_after_new\r\n    };\r\n    \r\n    verify_proof(og_proof) & verify_proof(new_proof)\r\n}\r\n\r\npub fn insert_item(\r\n    leaves: [Leaf; MAX_DEPTH],\r\n    num_leaves: u32,\r\n    new_key: u64,\r\n    new_value: Field\r\n) -> (InsertionResult, [Leaf; MAX_DEPTH], u32) {\r\n    // Find insertion position to maintain sorted order\r\n    let mut insert_idx = num_leaves; // Default to end\r\n    let mut prev_idx = 0;\r\n    \r\n    // Find the correct position for insertion (without break)\r\n    for i in 0..MAX_DEPTH {\r\n        let i_u32 = i as u32;\r\n        if i_u32 < num_leaves {\r\n            let is_greater = leaves[i].key > new_key;\r\n            let is_less_than_insert = i_u32 < insert_idx;\r\n            if is_greater & is_less_than_insert {\r\n                insert_idx = i_u32;\r\n            }\r\n            if i_u32 < insert_idx {\r\n                prev_idx = i_u32;\r\n            }\r\n        }\r\n    }\r\n    \r\n    let mut new_leaves = leaves;\r\n    let new_leaf_idx = num_leaves;\r\n    \r\n    // Create new leaf\r\n    let new_leaf = Leaf {\r\n        key: new_key,\r\n        next_idx: 0,\r\n        next_key: 0,\r\n        value: new_value\r\n    };\r\n    \r\n    // Insert at the end for now (simplified approach)\r\n    new_leaves[new_leaf_idx] = new_leaf;\r\n    \r\n    // Update previous leaf's next pointers if needed\r\n    if prev_idx < num_leaves {\r\n        new_leaves[prev_idx] = Leaf {\r\n            key: leaves[prev_idx].key,\r\n            next_idx: new_leaf_idx,\r\n            next_key: new_key,\r\n            value: leaves[prev_idx].value\r\n        };\r\n    }\r\n    \r\n    let new_count = num_leaves + 1;\r\n    \r\n    // Generate proofs\r\n    let og_proof = generate_proof(leaves, num_leaves, prev_idx);\r\n    let new_proof = generate_proof(new_leaves, new_count, new_leaf_idx);\r\n    let updated_prev_proof = generate_proof(new_leaves, new_count, prev_idx);\r\n    \r\n    let result = InsertionResult {\r\n        og_leaf_idx: og_proof.leaf_idx,\r\n        og_leaf_key: og_proof.leaf.key,\r\n        og_leaf_next_idx: og_proof.leaf.next_idx,\r\n        og_leaf_next_key: og_proof.leaf.next_key,\r\n        og_leaf_value: og_proof.leaf.value,\r\n        new_leaf_idx: new_proof.leaf_idx,\r\n        new_leaf_key: new_proof.leaf.key,\r\n        new_leaf_value: new_proof.leaf.value,\r\n        root_before: og_proof.root,\r\n        root_after: new_proof.root,\r\n        siblings_before: og_proof.siblings,\r\n        siblings_after_og: updated_prev_proof.siblings,\r\n        siblings_after_new: new_proof.siblings\r\n    };\r\n    \r\n    (result, new_leaves, new_count)\r\n}","path":"/home/drone/projects/ethrome25/circuits/lib/indexed-merkle-tree/src/indexed_merkle_tree.nr"},"67":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/drone/projects/ethrome25/circuits/lib/poseidon/src/poseidon2.nr"},"69":{"source":"use dep::std;\r\nuse dep::poseidon::poseidon2::Poseidon2;\r\n\r\n/// Poseidon CTR Mode Encryption Library\r\n/// \r\n/// This library provides Poseidon-based encryption in CTR mode for field elements.\r\n/// It includes functions for encrypting individual fields and batch encryption.\r\n\r\n/// Generate a keystream using Poseidon with shared_key and nonce\r\npub fn poseidon_keystream(shared_key: Field, nonce: u32) -> Field {\r\n    // === POSEIDON KEYSTREAM GENERATION ===\r\n    // Generate keystream using Poseidon with shared_key and nonce\r\n    \r\n    // Use the public hash function with shared_key and nonce\r\n    Poseidon2::hash([shared_key, nonce as Field], 2)\r\n}\r\n\r\n/// Encrypt a single field using Poseidon CTR mode\r\npub fn poseidon_ctr_encrypt(plaintext: Field, shared_key: Field, counter: u32) -> Field {\r\n    // === POSEIDON CTR MODE ENCRYPTION ===\r\n    // Use Poseidon to generate keystream for CTR mode encryption\r\n    \r\n    // Generate keystream using Poseidon with shared_key and counter\r\n    let keystream = poseidon_keystream(shared_key, counter);\r\n    \r\n    // Encrypt by adding keystream to plaintext (field arithmetic equivalent of XOR)\r\n    let ciphertext = plaintext + keystream;\r\n    \r\n    ciphertext\r\n}\r\n\r\n/// Decrypt a single field using Poseidon CTR mode\r\npub fn poseidon_ctr_decrypt(ciphertext: Field, shared_key: Field, counter: u32) -> Field {\r\n    // === POSEIDON CTR MODE DECRYPTION ===\r\n    // Decryption is the same as encryption in CTR mode\r\n    \r\n    // Generate the same keystream\r\n    let keystream = poseidon_keystream(shared_key, counter);\r\n    \r\n    // Decrypt by subtracting keystream from ciphertext\r\n    let plaintext = ciphertext - keystream;\r\n    \r\n    plaintext\r\n}\r\n\r\n/// Encrypt all four fields (amount, token_address, ref, encryption_key) in one function call\r\n/// This provides integrity checking - the ref value can be verified when absorbing the note\r\npub fn poseidon_encrypt_all_fields(\r\n    amount: Field, \r\n    token_address: Field,\r\n    ref: Field,\r\n    encryption_key: Field\r\n) -> (Field, Field, Field, Field) {\r\n    // === POSEIDON ENCRYPT ALL FIELDS ===\r\n    // Encrypt all four fields with different counters in one function call\r\n    // The ref value provides integrity checking when absorbing the note\r\n    \r\n    let encrypted_amount = poseidon_ctr_encrypt(amount, encryption_key, 0);\r\n    let encrypted_token_address = poseidon_ctr_encrypt(token_address, encryption_key, 1);\r\n    let encrypted_ref = poseidon_ctr_encrypt(ref, encryption_key, 2);\r\n    let encrypted_key = poseidon_ctr_encrypt(encryption_key, encryption_key, 3);\r\n    \r\n    (encrypted_amount, encrypted_token_address, encrypted_ref, encrypted_key)\r\n}\r\n\r\n/// Encrypt all four fields and return as array for cleaner API\r\npub fn poseidon_encrypt_all_fields_array(\r\n    amount: Field, \r\n    token_address: Field,\r\n    ref: Field,\r\n    encryption_key: Field\r\n) -> [Field; 3] {\r\n    // === POSEIDON ENCRYPT ALL FIELDS ARRAY ===\r\n    // Encrypt all four fields and return the first 3 as an array\r\n    // The ref value provides integrity checking when absorbing the note\r\n    \r\n    let encrypted_amount = poseidon_ctr_encrypt(amount, encryption_key, 0);\r\n    let encrypted_token_address = poseidon_ctr_encrypt(token_address, encryption_key, 1);\r\n    let encrypted_ref = poseidon_ctr_encrypt(ref, encryption_key, 2);\r\n    \r\n    [encrypted_amount, encrypted_token_address, encrypted_ref]\r\n}\r\n\r\n// ===== BASIC FUNCTIONALITY TESTS =====\r\n\r\n#[test]\r\nfn test_basic_encryption_decryption() {\r\n    // Test basic encryption and decryption round-trip\r\n    let plaintext = 12345 as Field;\r\n    let shared_key = Poseidon2::hash([42 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, shared_key, counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, shared_key, counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_zero_plaintext() {\r\n    // Test encryption of zero value\r\n    let plaintext = 0 as Field;\r\n    let shared_key = Poseidon2::hash([123 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, shared_key, counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, shared_key, counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_large_plaintext() {\r\n    // Test encryption of large field value (using a large but valid field value)\r\n    let plaintext = 21888242871839275222246405745257275088548364400416034343698204186575808495616 as Field; // p-1\r\n    let shared_key = Poseidon2::hash([456 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, shared_key, counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, shared_key, counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n// ===== COUNTER/KEYSTREAM TESTS =====\r\n\r\n#[test]\r\nfn test_different_counters_produce_different_ciphertexts() {\r\n    // Test that different counters produce different ciphertexts\r\n    let plaintext = 1000 as Field;\r\n    let shared_key = Poseidon2::hash([789 as Field], 1);\r\n    \r\n    let ciphertext1 = poseidon_ctr_encrypt(plaintext, shared_key, 0);\r\n    let ciphertext2 = poseidon_ctr_encrypt(plaintext, shared_key, 1);\r\n    let ciphertext3 = poseidon_ctr_encrypt(plaintext, shared_key, 2);\r\n    \r\n    // All ciphertexts should be different\r\n    assert(ciphertext1 != ciphertext2);\r\n    assert(ciphertext2 != ciphertext3);\r\n    assert(ciphertext1 != ciphertext3);\r\n    \r\n    // But all should decrypt to the same plaintext\r\n    assert(poseidon_ctr_decrypt(ciphertext1, shared_key, 0) == plaintext);\r\n    assert(poseidon_ctr_decrypt(ciphertext2, shared_key, 1) == plaintext);\r\n    assert(poseidon_ctr_decrypt(ciphertext3, shared_key, 2) == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_consistency() {\r\n    // Test that same inputs produce same keystream\r\n    let shared_key = Poseidon2::hash([999 as Field], 1);\r\n    let nonce = 5 as u32;\r\n    \r\n    let keystream1 = poseidon_keystream(shared_key, nonce);\r\n    let keystream2 = poseidon_keystream(shared_key, nonce);\r\n    \r\n    assert(keystream1 == keystream2);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_different_nonces() {\r\n    // Test that different nonces produce different keystreams\r\n    let shared_key = Poseidon2::hash([111 as Field], 1);\r\n    \r\n    let keystream1 = poseidon_keystream(shared_key, 0);\r\n    let keystream2 = poseidon_keystream(shared_key, 1);\r\n    let keystream3 = poseidon_keystream(shared_key, 2);\r\n    \r\n    assert(keystream1 != keystream2);\r\n    assert(keystream2 != keystream3);\r\n    assert(keystream1 != keystream3);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_different_keys() {\r\n    // Test that different keys produce different keystreams\r\n    let nonce = 0 as u32;\r\n    \r\n    let keystream1 = poseidon_keystream(Poseidon2::hash([1 as Field], 1), nonce);\r\n    let keystream2 = poseidon_keystream(Poseidon2::hash([2 as Field], 1), nonce);\r\n    let keystream3 = poseidon_keystream(Poseidon2::hash([3 as Field], 1), nonce);\r\n    \r\n    assert(keystream1 != keystream2);\r\n    assert(keystream2 != keystream3);\r\n    assert(keystream1 != keystream3);\r\n}\r\n\r\n// ===== BATCH ENCRYPTION TESTS =====\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_basic() {\r\n    // Test batch encryption of all four fields\r\n    let amount = 1000 as Field;\r\n    let token_address = 12345 as Field;\r\n    let ref = 67890 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    let (enc_amount, enc_token, enc_ref, enc_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, encryption_key\r\n    );\r\n    \r\n    // Verify each field can be decrypted individually\r\n    let dec_amount = poseidon_ctr_decrypt(enc_amount, encryption_key, 0);\r\n    let dec_token = poseidon_ctr_decrypt(enc_token, encryption_key, 1);\r\n    let dec_ref = poseidon_ctr_decrypt(enc_ref, encryption_key, 2);\r\n    let dec_key = poseidon_ctr_decrypt(enc_key, encryption_key, 3);\r\n    \r\n    assert(dec_amount == amount);\r\n    assert(dec_token == token_address);\r\n    assert(dec_ref == ref);\r\n    assert(dec_key == encryption_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_zero_values() {\r\n    // Test batch encryption with zero values\r\n    let amount = 0 as Field;\r\n    let token_address = 0 as Field;\r\n    let ref = 0 as Field;\r\n    let encryption_key = Poseidon2::hash([0 as Field], 1);\r\n    \r\n    let (enc_amount, enc_token, enc_ref, enc_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, encryption_key\r\n    );\r\n    \r\n    let dec_amount = poseidon_ctr_decrypt(enc_amount, encryption_key, 0);\r\n    let dec_token = poseidon_ctr_decrypt(enc_token, encryption_key, 1);\r\n    let dec_ref = poseidon_ctr_decrypt(enc_ref, encryption_key, 2);\r\n    let dec_key = poseidon_ctr_decrypt(enc_key, encryption_key, 3);\r\n    \r\n    assert(dec_amount == amount);\r\n    assert(dec_token == token_address);\r\n    assert(dec_ref == ref);\r\n    assert(dec_key == encryption_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_different_keys() {\r\n    // Test that different encryption keys produce different results\r\n    let amount = 1000 as Field;\r\n    let token_address = 2000 as Field;\r\n    let ref = 3000 as Field;\r\n    \r\n    let key1 = Poseidon2::hash([111 as Field], 1);\r\n    let key2 = Poseidon2::hash([222 as Field], 1);\r\n    \r\n    let (enc1_amount, enc1_token, enc1_ref, enc1_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, key1\r\n    );\r\n    \r\n    let (enc2_amount, enc2_token, enc2_ref, enc2_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, key2\r\n    );\r\n    \r\n    // Different keys should produce different ciphertexts\r\n    assert(enc1_amount != enc2_amount);\r\n    assert(enc1_token != enc2_token);\r\n    assert(enc1_ref != enc2_ref);\r\n    assert(enc1_key != enc2_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_integrity_check() {\r\n    // Test that the ref and key values provide integrity checking\r\n    let amount = 5000 as Field;\r\n    let token_address = 6000 as Field;\r\n    let ref = 7000 as Field;\r\n    let encryption_key = Poseidon2::hash([777 as Field], 1);\r\n    \r\n    let (enc_amount, enc_token, enc_ref, enc_key) = poseidon_encrypt_all_fields(\r\n        amount, token_address, ref, encryption_key\r\n    );\r\n    \r\n    // Decrypt the ref and key values - they should match the original values\r\n    let decrypted_ref = poseidon_ctr_decrypt(enc_ref, encryption_key, 2);\r\n    let decrypted_key = poseidon_ctr_decrypt(enc_key, encryption_key, 3);\r\n    assert(decrypted_ref == ref);\r\n    assert(decrypted_key == encryption_key);\r\n    \r\n    // This provides integrity: if someone tries to use a different key to decrypt,\r\n    // the values won't match, indicating tampering\r\n    let wrong_key = Poseidon2::hash([888 as Field], 1);\r\n    let wrong_decrypted_ref = poseidon_ctr_decrypt(enc_ref, wrong_key, 2);\r\n    let wrong_decrypted_key = poseidon_ctr_decrypt(enc_key, wrong_key, 3);\r\n    assert(wrong_decrypted_ref != ref);\r\n    assert(wrong_decrypted_key != encryption_key);\r\n}\r\n\r\n#[test]\r\nfn test_encrypt_all_fields_array() {\r\n    // Test the array version of encrypt all fields\r\n    let amount = 1000 as Field;\r\n    let token_address = 2000 as Field;\r\n    let ref = 3000 as Field;\r\n    let encryption_key = Poseidon2::hash([999 as Field], 1);\r\n    \r\n    let encrypted_array = poseidon_encrypt_all_fields_array(amount, token_address, ref, encryption_key);\r\n    \r\n    // Verify array has 3 elements\r\n    assert(encrypted_array.len() == 3);\r\n    \r\n    // Verify each element can be decrypted\r\n    let dec_amount = poseidon_ctr_decrypt(encrypted_array[0], encryption_key, 0);\r\n    let dec_token = poseidon_ctr_decrypt(encrypted_array[1], encryption_key, 1);\r\n    let dec_ref = poseidon_ctr_decrypt(encrypted_array[2], encryption_key, 2);\r\n    \r\n    assert(dec_amount == amount);\r\n    assert(dec_token == token_address);\r\n    assert(dec_ref == ref);\r\n}\r\n\r\n// ===== SECURITY TESTS =====\r\n\r\n#[test]\r\nfn test_wrong_key_fails_decryption() {\r\n    // Test that decryption with wrong key fails\r\n    let plaintext = 5000 as Field;\r\n    let correct_key = Poseidon2::hash([111 as Field], 1);\r\n    let wrong_key = Poseidon2::hash([222 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, correct_key, counter);\r\n    let wrong_decrypted = poseidon_ctr_decrypt(ciphertext, wrong_key, counter);\r\n    \r\n    // Should not recover original plaintext\r\n    assert(wrong_decrypted != plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_wrong_counter_fails_decryption() {\r\n    // Test that decryption with wrong counter fails\r\n    let plaintext = 7777 as Field;\r\n    let shared_key = Poseidon2::hash([333 as Field], 1);\r\n    let correct_counter = 2 as u32;\r\n    let wrong_counter = 3 as u32;\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, shared_key, correct_counter);\r\n    let wrong_decrypted = poseidon_ctr_decrypt(ciphertext, shared_key, wrong_counter);\r\n    \r\n    // Should not recover original plaintext\r\n    assert(wrong_decrypted != plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_encryption_deterministic() {\r\n    // Test that same inputs always produce same ciphertext\r\n    let plaintext = 8888 as Field;\r\n    let shared_key = Poseidon2::hash([444 as Field], 1);\r\n    let counter = 1 as u32;\r\n    \r\n    let ciphertext1 = poseidon_ctr_encrypt(plaintext, shared_key, counter);\r\n    let ciphertext2 = poseidon_ctr_encrypt(plaintext, shared_key, counter);\r\n    \r\n    // Same inputs should produce same ciphertext\r\n    assert(ciphertext1 == ciphertext2);\r\n}\r\n\r\n#[test]\r\nfn test_different_plaintexts_different_ciphertexts() {\r\n    // Test that different plaintexts produce different ciphertexts\r\n    let shared_key = Poseidon2::hash([555 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    let ciphertext1 = poseidon_ctr_encrypt(1000 as Field, shared_key, counter);\r\n    let ciphertext2 = poseidon_ctr_encrypt(2000 as Field, shared_key, counter);\r\n    let ciphertext3 = poseidon_ctr_encrypt(3000 as Field, shared_key, counter);\r\n    \r\n    // Different plaintexts should produce different ciphertexts\r\n    assert(ciphertext1 != ciphertext2);\r\n    assert(ciphertext2 != ciphertext3);\r\n    assert(ciphertext1 != ciphertext3);\r\n}\r\n\r\n// ===== EDGE CASE TESTS =====\r\n\r\n#[test]\r\nfn test_max_counter_value() {\r\n    // Test with maximum counter value\r\n    let plaintext = 1234 as Field;\r\n    let shared_key = Poseidon2::hash([666 as Field], 1);\r\n    let max_counter = 4294967295 as u32; // u32::MAX\r\n    \r\n    let ciphertext = poseidon_ctr_encrypt(plaintext, shared_key, max_counter);\r\n    let decrypted = poseidon_ctr_decrypt(ciphertext, shared_key, max_counter);\r\n    \r\n    assert(decrypted == plaintext);\r\n}\r\n\r\n#[test]\r\nfn test_encryption_preserves_field_arithmetic() {\r\n    // Test that encryption preserves field arithmetic properties\r\n    let a = 1000 as Field;\r\n    let b = 2000 as Field;\r\n    let shared_key = Poseidon2::hash([777 as Field], 1);\r\n    let counter = 0 as u32;\r\n    \r\n    // Encrypt individual values\r\n    let enc_a = poseidon_ctr_encrypt(a, shared_key, counter);\r\n    let enc_b = poseidon_ctr_encrypt(b, shared_key, counter);\r\n    \r\n    // Decrypt and verify\r\n    let dec_a = poseidon_ctr_decrypt(enc_a, shared_key, counter);\r\n    let dec_b = poseidon_ctr_decrypt(enc_b, shared_key, counter);\r\n    \r\n    assert(dec_a == a);\r\n    assert(dec_b == b);\r\n}\r\n\r\n#[test]\r\nfn test_keystream_uniformity() {\r\n    // Test that keystreams appear uniformly distributed\r\n    let shared_key = Poseidon2::hash([888 as Field], 1);\r\n    \r\n    let keystream1 = poseidon_keystream(shared_key, 0);\r\n    let keystream2 = poseidon_keystream(shared_key, 1);\r\n    let keystream3 = poseidon_keystream(shared_key, 2);\r\n    let keystream4 = poseidon_keystream(shared_key, 3);\r\n    let keystream5 = poseidon_keystream(shared_key, 4);\r\n    \r\n    // All keystreams should be different (very high probability)\r\n    assert(keystream1 != keystream2);\r\n    assert(keystream2 != keystream3);\r\n    assert(keystream3 != keystream4);\r\n    assert(keystream4 != keystream5);\r\n    assert(keystream1 != keystream3);\r\n    assert(keystream1 != keystream4);\r\n    assert(keystream1 != keystream5);\r\n    assert(keystream2 != keystream4);\r\n    assert(keystream2 != keystream5);\r\n    assert(keystream3 != keystream5);\r\n}\r\n","path":"/home/drone/projects/ethrome25/circuits/lib/poseidon-ctr-encryption/src/lib.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}